#!/usr/bin/env python3
"""
Arch Linux Package Add Tool
Adds a new package to the manifest and installs it on the system.
"""

import subprocess
import sys
import tomllib
import re
from pathlib import Path
from typing import Dict, List, Tuple


def run_command(cmd: List[str], check: bool = True) -> Tuple[bool, str]:
    """Run a shell command and return success status and output."""
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=check)
        return True, result.stdout.strip()
    except subprocess.CalledProcessError as e:
        return False, e.stderr.strip() if e.stderr else str(e)


def is_package_installed(package: str) -> bool:
    """Check if a package is already installed."""
    success, _ = run_command(['pacman', '-Q', package], check=False)
    return success


def search_package_info(package: str, source: str = "official") -> Tuple[bool, str]:
    """Search for package information to get description."""
    if source == "aur":
        # Try yay or paru for AUR package info
        for helper in ['yay', 'paru']:
            success, _ = run_command(['which', helper], check=False)
            if success:
                success, output = run_command([helper, '-Si', package], check=False)
                if success:
                    # Extract description from output
                    for line in output.split('\n'):
                        if line.strip().startswith('Description'):
                            desc = line.split(':', 1)[1].strip()
                            return True, desc
                break
        return False, f"AUR package {package}"
    else:
        success, output = run_command(['pacman', '-Si', package], check=False)
        if success:
            # Extract description from output
            for line in output.split('\n'):
                if line.strip().startswith('Description'):
                    desc = line.split(':', 1)[1].strip()
                    return True, desc
        return False, f"Package {package}"


def install_package(package: str, source: str = "official") -> bool:
    """Install a package."""
    if is_package_installed(package):
        print(f"✓ Package {package} is already installed")
        return True
    
    print(f"Installing {package} from {source}...")
    
    if source == "aur":
        # Try yay or paru for AUR packages
        for helper in ['yay', 'paru']:
            success, _ = run_command(['which', helper], check=False)
            if success:
                success, output = run_command([helper, '-S', '--needed', '--noconfirm', package], check=False)
                if success:
                    print(f"✓ Package {package} installed successfully")
                    return True
                else:
                    print(f"Error installing {package}: {output}", file=sys.stderr)
                    return False
        
        print("Error: No AUR helper (yay/paru) found", file=sys.stderr)
        return False
    else:
        success, output = run_command(['sudo', 'pacman', '-S', '--needed', '--noconfirm', package], check=False)
        if success:
            print(f"✓ Package {package} installed successfully")
            return True
        else:
            print(f"Error installing {package}: {output}", file=sys.stderr)
            return False


def determine_category(package: str, description: str) -> str:
    """Determine the appropriate category for a package based on its name and description."""
    desc_lower = description.lower()
    package_lower = package.lower()
    
    # Audio-related packages
    if any(word in desc_lower or word in package_lower for word in 
           ['audio', 'sound', 'alsa', 'pulse', 'pipewire', 'music', 'media', 'player']):
        return 'audio'
    
    # Bluetooth packages
    if any(word in desc_lower or word in package_lower for word in 
           ['bluetooth', 'bluez']):
        return 'bluetooth'
    
    # Development packages
    if any(word in desc_lower or word in package_lower for word in 
           ['compiler', 'development', 'programming', 'language', 'build', 'make', 'cmake', 
            'gcc', 'clang', 'python', 'node', 'java', 'rust', 'go']):
        return 'development'
    
    # Desktop/GUI packages
    if any(word in desc_lower or word in package_lower for word in 
           ['desktop', 'gui', 'window', 'terminal', 'emulator', 'editor', 'browser']):
        return 'desktop'
    
    # Network packages
    if any(word in desc_lower or word in package_lower for word in 
           ['network', 'internet', 'web', 'http', 'ftp', 'ssh', 'vpn', 'wifi']):
        return 'network'
    
    # Default to optional for unknown packages
    return 'optional'


def add_to_manifest(manifest_path: Path, package: str, source: str, description: str, category: str = None):
    """Add a package to the manifest file."""
    # Read the current manifest file as text to preserve formatting
    with open(manifest_path, 'r') as f:
        content = f.read()
    
    # Auto-determine category if not specified
    if not category:
        category = determine_category(package, description)
    
    # Find the appropriate section to add the package
    section_pattern = rf'\[packages\.{category}\]'
    section_match = re.search(section_pattern, content)
    
    if not section_match:
        print(f"Warning: Category [{category}] not found in manifest", file=sys.stderr)
        print(f"Available categories: core, audio, bluetooth, development, desktop, network, optional", file=sys.stderr)
        category = 'optional'
        section_pattern = r'\[packages\.optional\]'
        section_match = re.search(section_pattern, content)
    
    if section_match:
        # Find the end of the section
        section_start = section_match.end()
        
        # Find the next section or end of file
        next_section = re.search(r'\n\[', content[section_start:])
        if next_section:
            section_end = section_start + next_section.start()
            insertion_point = section_end
        else:
            # Add at the end of the file
            insertion_point = len(content)
        
        # Create the package entry
        source_attr = f', source = "{source}"' if source == "aur" else ""
        package_entry = f'{package} = {{ reason = "{description}"{source_attr} }}\n'
        
        # Insert the package entry
        new_content = content[:insertion_point] + package_entry + content[insertion_point:]
        
        # Write back to file
        with open(manifest_path, 'w') as f:
            f.write(new_content)
        
        print(f"✓ Added {package} to manifest in category [{category}]")
    else:
        print(f"Error: Could not find category [{category}] in manifest", file=sys.stderr)
        return False
    
    return True


def main():
    """Main entry point."""
    if len(sys.argv) < 2:
        print("Usage: arch-add <package-name> [source]", file=sys.stderr)
        print("  source: 'official' (default) or 'aur'", file=sys.stderr)
        sys.exit(1)
    
    package = sys.argv[1]
    source = sys.argv[2] if len(sys.argv) > 2 and sys.argv[2] else "official"
    
    # Validate source
    if source not in ["official", "aur"]:
        print(f"Error: Invalid source '{source}'. Must be 'official' or 'aur'", file=sys.stderr)
        sys.exit(1)
    
    # Determine paths
    script_dir = Path(__file__).parent
    manifest_path = script_dir / 'arch.toml'
    
    if not manifest_path.exists():
        print(f"Error: Manifest file not found at {manifest_path}", file=sys.stderr)
        sys.exit(1)
    
    print(f"Adding package '{package}' from {source} repository...")
    
    # Get package information
    success, description = search_package_info(package, source)
    if not success:
        description = f"{source.title()} package {package}"
        print(f"Warning: Could not get package description, using default: {description}")
    
    # Install the package
    if not install_package(package, source):
        print(f"Failed to install package {package}", file=sys.stderr)
        sys.exit(1)
    
    # Add to manifest
    if not add_to_manifest(manifest_path, package, source, description):
        print(f"Failed to add package {package} to manifest", file=sys.stderr)
        sys.exit(1)
    
    print(f"\n✅ Successfully added and installed {package}!")
    print("Next steps:")
    print("  1. Review the manifest file and adjust the category/description if needed")
    print("  2. Run 'make -C os/arch lock-packages' to update the lock file")
    print("  3. Commit the changes to your dotfiles repository")


if __name__ == '__main__':
    main()