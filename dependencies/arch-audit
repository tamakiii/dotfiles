#!/usr/bin/env python3
"""
Arch Linux Package Auditor
Audits packages for security updates, unused packages, and manifest compliance.
"""

import subprocess
import sys
import tomllib
import json
from pathlib import Path
from typing import Dict, List, Set, Tuple
from datetime import datetime


def run_command(cmd: List[str], check: bool = True) -> Tuple[bool, str]:
    """Run a shell command and return success status and output."""
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=check)
        return True, result.stdout.strip()
    except subprocess.CalledProcessError as e:
        return False, e.stderr.strip() if e.stderr else str(e)


def load_manifest(manifest_path: Path) -> Dict:
    """Load the arch.toml manifest file."""
    try:
        with open(manifest_path, 'rb') as f:
            return tomllib.load(f)
    except Exception as e:
        print(f"Error loading manifest: {e}", file=sys.stderr)
        sys.exit(1)


def load_lock_file(lock_path: Path) -> Dict:
    """Load the arch.lock file if it exists."""
    if not lock_path.exists():
        return None
    try:
        with open(lock_path, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"Warning: Could not load lock file: {e}", file=sys.stderr)
        return None


def get_all_installed_packages() -> Dict[str, str]:
    """Get all installed packages with their versions."""
    success, output = run_command(['pacman', '-Q'])
    packages = {}
    if success:
        for line in output.split('\n'):
            if line.strip():
                parts = line.strip().split(' ', 1)
                if len(parts) == 2:
                    packages[parts[0]] = parts[1]
    return packages


def get_explicitly_installed_packages() -> Set[str]:
    """Get packages that were explicitly installed by the user."""
    success, output = run_command(['pacman', '-Qe'])
    packages = set()
    if success:
        for line in output.split('\n'):
            if line.strip():
                package_name = line.strip().split(' ')[0]
                packages.add(package_name)
    return packages


def get_aur_packages() -> Set[str]:
    """Get all AUR packages."""
    success, output = run_command(['pacman', '-Qm'])
    packages = set()
    if success:
        for line in output.split('\n'):
            if line.strip():
                package_name = line.strip().split(' ')[0]
                packages.add(package_name)
    return packages


def get_outdated_packages() -> List[Tuple[str, str, str]]:
    """Get packages that have available updates."""
    success, output = run_command(['pacman', '-Qu'], check=False)
    outdated = []
    if success and output:
        for line in output.split('\n'):
            if line.strip() and ' -> ' in line:
                parts = line.split(' -> ')
                if len(parts) == 2:
                    pkg_current = parts[0].strip().split(' ')
                    if len(pkg_current) == 2:
                        package_name = pkg_current[0]
                        current_version = pkg_current[1]
                        new_version = parts[1].strip()
                        outdated.append((package_name, current_version, new_version))
    return outdated


def resolve_package_name(declared_name: str, package_info: Dict) -> str:
    """Resolve the actual package name from the manifest entry."""
    if isinstance(package_info, dict) and 'package' in package_info:
        return package_info['package']
    return declared_name


def collect_manifest_packages(manifest: Dict) -> Set[str]:
    """Collect all packages declared in the manifest."""
    manifest_packages = set()
    
    if 'packages' not in manifest:
        return manifest_packages
    
    for category, packages in manifest['packages'].items():
        for declared_name, package_info in packages.items():
            actual_name = resolve_package_name(declared_name, package_info)
            manifest_packages.add(actual_name)
    
    return manifest_packages


def check_security_updates():
    """Check for available security updates."""
    print("üîç Checking for package updates...")
    outdated = get_outdated_packages()
    
    if outdated:
        print(f"‚ö†Ô∏è  Found {len(outdated)} packages with available updates:")
        for package, current, new in outdated:
            print(f"  ‚Ä¢ {package}: {current} ‚Üí {new}")
        print("\nRun 'sudo pacman -Syu' to update all packages.")
        print("Or run 'make -C os/arch update-packages' to update and regenerate lock file.")
        return False
    else:
        print("‚úì All packages are up to date")
        return True


def check_manifest_compliance(manifest: Dict, installed_packages: Dict[str, str]):
    """Check if the system complies with the manifest."""
    print("\nüîç Checking manifest compliance...")
    
    manifest_packages = collect_manifest_packages(manifest)
    
    # Check for missing packages
    missing_packages = []
    for package in manifest_packages:
        if package not in installed_packages:
            missing_packages.append(package)
    
    if missing_packages:
        print(f"‚ö†Ô∏è  Found {len(missing_packages)} packages missing from system:")
        for package in missing_packages:
            print(f"  ‚Ä¢ {package}")
        print("\nRun 'make -C os/arch install-packages' to install missing packages.")
        return False
    else:
        print("‚úì All manifest packages are installed")
        return True


def check_orphaned_packages(manifest: Dict, installed_packages: Dict[str, str]):
    """Check for packages not in the manifest that might be unused."""
    print("\nüîç Checking for potentially unused packages...")
    
    manifest_packages = collect_manifest_packages(manifest)
    explicitly_installed = get_explicitly_installed_packages()
    
    # Find explicitly installed packages not in manifest
    orphaned_candidates = []
    for package in explicitly_installed:
        if package not in manifest_packages:
            orphaned_candidates.append(package)
    
    if orphaned_candidates:
        print(f"‚ö†Ô∏è  Found {len(orphaned_candidates)} explicitly installed packages not in manifest:")
        for package in orphaned_candidates[:10]:  # Limit output
            version = installed_packages.get(package, "unknown")
            print(f"  ‚Ä¢ {package} ({version})")
        
        if len(orphaned_candidates) > 10:
            print(f"  ... and {len(orphaned_candidates) - 10} more")
        
        print("\nThese packages might be:")
        print("  1. Packages you no longer need")
        print("  2. Dependencies that should be in the manifest")
        print("  3. One-off tools that don't belong in dotfiles")
        print("\nConsider adding important ones to the manifest or removing unused ones.")
        return False
    else:
        print("‚úì No orphaned packages found")
        return True


def check_lock_file_drift(lock_file: Dict, installed_packages: Dict[str, str]):
    """Check if the current system has drifted from the lock file."""
    if not lock_file:
        print("\n‚ö†Ô∏è  No lock file found - run 'make -C os/arch lock-packages' to generate one")
        return False
    
    print("\nüîç Checking lock file drift...")
    
    drift_detected = False
    
    # Check packages in lock file
    for category, packages in lock_file.get('packages', {}).items():
        for declared_name, lock_info in packages.items():
            package_name = lock_info['package']
            lock_version = lock_info['version']
            current_version = installed_packages.get(package_name)
            
            if not current_version:
                print(f"‚ö†Ô∏è  Package {package_name} in lock file but not installed")
                drift_detected = True
            elif current_version != lock_version:
                print(f"‚ö†Ô∏è  Version drift for {package_name}: {lock_version} (lock) ‚Üí {current_version} (current)")
                drift_detected = True
    
    if not drift_detected:
        print("‚úì System matches lock file")
        return True
    else:
        print("\nRun 'make -C os/arch lock-packages' to update lock file with current versions.")
        return False


def main():
    """Main entry point."""
    # Determine paths
    script_dir = Path(__file__).parent
    manifest_path = script_dir / 'arch.toml'
    lock_path = script_dir / 'arch.lock'
    
    if not manifest_path.exists():
        print(f"Error: Manifest file not found at {manifest_path}", file=sys.stderr)
        sys.exit(1)
    
    print("üîç Starting package audit...")
    print(f"Manifest: {manifest_path}")
    print(f"Lock file: {lock_path}")
    
    # Load files
    manifest = load_manifest(manifest_path)
    lock_file = load_lock_file(lock_path)
    installed_packages = get_all_installed_packages()
    
    print(f"Total installed packages: {len(installed_packages)}")
    
    # Run checks
    checks_passed = 0
    total_checks = 4
    
    if check_security_updates():
        checks_passed += 1
    
    if check_manifest_compliance(manifest, installed_packages):
        checks_passed += 1
    
    if check_orphaned_packages(manifest, installed_packages):
        checks_passed += 1
    
    if check_lock_file_drift(lock_file, installed_packages):
        checks_passed += 1
    
    # Summary
    print(f"\nüìä Audit Summary: {checks_passed}/{total_checks} checks passed")
    
    if checks_passed == total_checks:
        print("‚úÖ System is in excellent condition!")
        sys.exit(0)
    else:
        print("‚ö†Ô∏è  Some issues found - see above for recommendations")
        sys.exit(1)


if __name__ == '__main__':
    main()