#!/usr/bin/env python3
"""
Arch Linux Package Remove Tool
Removes a package from the manifest and optionally from the system.
"""

import subprocess
import sys
import re
from pathlib import Path
from typing import Tuple


def run_command(cmd: list, check: bool = True) -> Tuple[bool, str]:
    """Run a shell command and return success status and output."""
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=check)
        return True, result.stdout.strip()
    except subprocess.CalledProcessError as e:
        return False, e.stderr.strip() if e.stderr else str(e)


def is_package_installed(package: str) -> bool:
    """Check if a package is already installed."""
    success, _ = run_command(['pacman', '-Q', package], check=False)
    return success


def get_package_dependents(package: str) -> list:
    """Get packages that depend on this package."""
    success, output = run_command(['pacman', '-Qi', package], check=False)
    if not success:
        return []
    
    dependents = []
    for line in output.split('\n'):
        if line.strip().startswith('Required By'):
            deps = line.split(':', 1)[1].strip()
            if deps != 'None':
                dependents = [dep.strip() for dep in deps.split()]
            break
    
    return dependents


def remove_package(package: str, force: bool = False) -> bool:
    """Remove a package from the system."""
    if not is_package_installed(package):
        print(f"✓ Package {package} is not installed")
        return True
    
    # Check for dependents
    dependents = get_package_dependents(package)
    if dependents and not force:
        print(f"⚠️  Package {package} is required by: {', '.join(dependents)}")
        response = input("Remove anyway? This may break other packages. [y/N]: ")
        if response.lower() != 'y':
            print("Removal cancelled")
            return False
    
    print(f"Removing {package}...")
    
    # Remove package
    cmd = ['sudo', 'pacman', '-R', '--noconfirm', package]
    success, output = run_command(cmd, check=False)
    
    if success:
        print(f"✓ Package {package} removed successfully")
        return True
    else:
        # Try removing with dependencies if it failed
        print(f"Standard removal failed, trying with dependencies...")
        cmd = ['sudo', 'pacman', '-Rs', '--noconfirm', package]
        success, output = run_command(cmd, check=False)
        
        if success:
            print(f"✓ Package {package} and unused dependencies removed successfully")
            return True
        else:
            print(f"Error removing {package}: {output}", file=sys.stderr)
            return False


def find_package_in_manifest(manifest_path: Path, package: str) -> tuple:
    """Find a package in the manifest and return its location."""
    with open(manifest_path, 'r') as f:
        content = f.read()
    
    # Look for the package entry in any category
    # Pattern to match: package_name = { ... }
    pattern = rf'^{re.escape(package)}\s*=\s*\{{[^}}]*\}}'
    
    for match in re.finditer(pattern, content, re.MULTILINE):
        # Find which category this package belongs to
        before_match = content[:match.start()]
        category_matches = list(re.finditer(r'\[packages\.([^\]]+)\]', before_match))
        
        if category_matches:
            category = category_matches[-1].group(1)
            return match.start(), match.end(), category
    
    return None, None, None


def remove_from_manifest(manifest_path: Path, package: str) -> bool:
    """Remove a package from the manifest file."""
    start, end, category = find_package_in_manifest(manifest_path, package)
    
    if start is None:
        print(f"Warning: Package {package} not found in manifest", file=sys.stderr)
        return False
    
    # Read the current manifest file
    with open(manifest_path, 'r') as f:
        content = f.read()
    
    # Remove the package line (including the newline)
    if end < len(content) and content[end] == '\n':
        end += 1
    
    new_content = content[:start] + content[end:]
    
    # Write back to file
    with open(manifest_path, 'w') as f:
        f.write(new_content)
    
    print(f"✓ Removed {package} from manifest (category: {category})")
    return True


def main():
    """Main entry point."""
    if len(sys.argv) < 2:
        print("Usage: arch-remove <package-name> [--system-only|--manifest-only]", file=sys.stderr)
        print("  --system-only: Remove only from system, keep in manifest", file=sys.stderr)
        print("  --manifest-only: Remove only from manifest, keep on system", file=sys.stderr)
        sys.exit(1)
    
    package = sys.argv[1]
    
    # Parse options
    system_only = '--system-only' in sys.argv[2:]
    manifest_only = '--manifest-only' in sys.argv[2:]
    
    if system_only and manifest_only:
        print("Error: Cannot specify both --system-only and --manifest-only", file=sys.stderr)
        sys.exit(1)
    
    # Determine paths
    script_dir = Path(__file__).parent
    manifest_path = script_dir / 'arch.toml'
    
    if not manifest_path.exists():
        print(f"Error: Manifest file not found at {manifest_path}", file=sys.stderr)
        sys.exit(1)
    
    print(f"Removing package '{package}'...")
    
    success = True
    
    # Remove from manifest (unless system-only)
    if not system_only:
        if not remove_from_manifest(manifest_path, package):
            success = False
    
    # Remove from system (unless manifest-only)
    if not manifest_only:
        if not remove_package(package):
            success = False
    
    if success:
        print(f"\n✅ Successfully removed {package}!")
        print("Next steps:")
        if not system_only:
            print("  1. Review the manifest file to ensure the removal is correct")
            print("  2. Run 'make -C os/arch lock-packages' to update the lock file")
            print("  3. Commit the changes to your dotfiles repository")
        if not manifest_only:
            print("  • Run 'pacman -Qtdq | sudo pacman -Rs -' to remove orphaned dependencies")
    else:
        print(f"\n❌ Some operations failed during removal of {package}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()