#!/usr/bin/env bash
#
# scriptty - Enhanced terminal session recorder using the 'script' command
#
# Usage: scriptty [OPTIONS] [-- COMMAND [ARGS...]]
#
# Records terminal sessions to timestamped log files for later review.
# By default, logs are saved to /tmp/dev/<tty>_<timestamp>
#
# Options:
#   -d, --dir DIR      Custom log directory (default: /tmp/dev)
#   -a, --append       Append to existing log file instead of creating new
#   -s, --status       Check if a script session is currently active
#   -l, --list         List recent session logs
#   -h, --help         Show this help message
#
# Examples:
#   scriptty                    # Start recording interactive shell
#   scriptty -d ~/logs         # Save logs to custom directory
#   scriptty -s                # Check if recording is active
#   scriptty -l                # List recent session logs
#   scriptty -- claude         # Record a claude session
#   scriptty -- npm test       # Record npm test output
#   scriptty -d ~/logs -- make # Record make with custom log dir

set -euo pipefail

# Default configuration
DEFAULT_LOG_DIR="/tmp/dev"
LOG_DIR="$DEFAULT_LOG_DIR"
APPEND_MODE=false
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# Function to display usage
show_help() {
    sed -n '3,25p' "$0" | sed 's/^# //' | sed 's/^#//'
    exit 0
}

# Function to get current TTY
get_tty() {
    local tty_id
    tty_id=$(ps -p $$ -o tty= | xargs)
    
    if [[ "$tty_id" == "??" ]] || [[ -z "$tty_id" ]]; then
        echo ""
        return 1
    fi
    
    echo "$tty_id"
    return 0
}

# Function to check if script is already running
check_script_status() {
    if [[ -n "${SCRIPT:-}" ]]; then
        echo "[OK] Script session is currently active"
        echo "     Recording to: $SCRIPT"
        return 0
    else
        echo "[INFO] No active script session"
        return 1
    fi
}

# Function to list recent logs
list_logs() {
    local search_dir="${1:-$DEFAULT_LOG_DIR}"
    
    if [[ ! -d "$search_dir" ]]; then
        echo "[INFO] No logs found (directory doesn't exist: $search_dir)"
        return 1
    fi
    
    local logs
    logs=$(find "$search_dir" -name "*_*" -type f 2>/dev/null | sort -r | head -10)
    
    if [[ -z "$logs" ]]; then
        echo "[INFO] No session logs found in $search_dir"
        return 1
    fi
    
    echo "Recent session logs:"
    echo "$logs" | while read -r log; do
        local size
        size=$(ls -lh "$log" | awk '{print $5}')
        local modified
        modified=$(ls -l "$log" | awk '{print $6, $7, $8}')
        echo "  * $(basename "$log") (${size}, ${modified})"
    done
}

# Variables for command execution
COMMAND_TO_RUN=""
COMMAND_ARGS=()

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -d|--dir)
            LOG_DIR="$2"
            shift 2
            ;;
        -a|--append)
            APPEND_MODE=true
            shift
            ;;
        -s|--status)
            check_script_status
            exit $?
            ;;
        -l|--list)
            list_logs "${2:-$DEFAULT_LOG_DIR}"
            exit $?
            ;;
        -h|--help)
            show_help
            ;;
        --)
            # Everything after -- is the command to run
            shift
            if [[ $# -gt 0 ]]; then
                COMMAND_TO_RUN="$1"
                shift
                COMMAND_ARGS=("$@")
            fi
            break
            ;;
        *)
            echo "[ERROR] Unknown option: $1"
            echo "        Use -h or --help for usage information"
            exit 1
            ;;
    esac
done

# Check if script is already running
if [[ -n "${SCRIPT:-}" ]]; then
    echo "[WARNING] Script session already active!"
    echo "          Recording to: $SCRIPT"
    echo "          Exit the current session before starting a new one"
    exit 1
fi

# Get TTY information
TTY_ID=$(get_tty)
if [[ -z "$TTY_ID" ]]; then
    echo "[ERROR] No valid TTY detected"
    echo "        This command must be run in an interactive terminal"
    exit 1
fi

# Create log directory if it doesn't exist
if [[ ! -d "$LOG_DIR" ]]; then
    mkdir -p "$LOG_DIR" || {
        echo "[ERROR] Failed to create log directory: $LOG_DIR"
        exit 1
    }
fi

# Determine log file path
if [[ "$APPEND_MODE" == true ]]; then
    # Find the most recent log file for this TTY
    LOG_FILE=$(find "$LOG_DIR" -name "${TTY_ID}_*" -type f 2>/dev/null | sort -r | head -1)
    
    if [[ -z "$LOG_FILE" ]]; then
        # No existing log file, create a new one
        if [[ -n "$COMMAND_TO_RUN" ]]; then
            # Include command name in filename (sanitize it first)
            SAFE_CMD=$(basename "$COMMAND_TO_RUN" | tr -cd '[:alnum:]._-')
            LOG_FILE="${LOG_DIR}/${TTY_ID}_${SAFE_CMD}_${TIMESTAMP}"
        else
            LOG_FILE="${LOG_DIR}/${TTY_ID}_${TIMESTAMP}"
        fi
        echo "[INFO] No existing log found, creating new file"
    else
        echo "[OK] Appending to existing log"
    fi
else
    if [[ -n "$COMMAND_TO_RUN" ]]; then
        # Include command name in filename (sanitize it first)
        SAFE_CMD=$(basename "$COMMAND_TO_RUN" | tr -cd '[:alnum:]._-')
        LOG_FILE="${LOG_DIR}/${TTY_ID}_${SAFE_CMD}_${TIMESTAMP}"
    else
        LOG_FILE="${LOG_DIR}/${TTY_ID}_${TIMESTAMP}"
    fi
fi

# Start script session
echo "[OK] Starting terminal recording"
echo "     TTY: $TTY_ID"
echo "     Log: $LOG_FILE"
if [[ -n "$COMMAND_TO_RUN" ]]; then
    echo "     Command: $COMMAND_TO_RUN"
    if [[ ${#COMMAND_ARGS[@]} -gt 0 ]]; then
        echo "     Args: ${COMMAND_ARGS[*]}"
    fi
else
    echo "     Type 'exit' or press Ctrl+D to stop recording"
fi
echo ""

# Run script command
if [[ -n "$COMMAND_TO_RUN" ]]; then
    # Execute the specified command
    if [[ "$APPEND_MODE" == true ]] && [[ -f "$LOG_FILE" ]]; then
        script -a "$LOG_FILE" "$COMMAND_TO_RUN" "${COMMAND_ARGS[@]}"
    else
        script "$LOG_FILE" "$COMMAND_TO_RUN" "${COMMAND_ARGS[@]}"
    fi
else
    # Interactive shell mode
    if [[ "$APPEND_MODE" == true ]] && [[ -f "$LOG_FILE" ]]; then
        script -a "$LOG_FILE"
    else
        script "$LOG_FILE"
    fi
fi

# Post-session information
echo ""
echo "[OK] Recording session ended"
echo "     Log saved to: $LOG_FILE"
echo "     Size: $(ls -lh "$LOG_FILE" | awk '{print $5}')"
echo "     View with: cat '$LOG_FILE'"